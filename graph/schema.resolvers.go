package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.64

import (
	"context"
	"fmt"

	generated1 "github.com/bbernstein/flowebb-go/graph/generated"
	"github.com/bbernstein/flowebb-go/graph/model"
)

// Stations is the resolver for the stations field.
func (r *queryResolver) Stations(ctx context.Context, lat *float64, lon *float64, limit *int) ([]*model.Station, error) {
	if lat == nil || lon == nil {
		return nil, fmt.Errorf("lat and lon are required")
	}

	limitVal := 5
	if limit != nil {
		limitVal = *limit
	}

	stations, err := r.StationFinder.FindNearestStations(ctx, *lat, *lon, limitVal)
	if err != nil {
		return nil, err
	}

	// Convert internal models to GraphQL models
	result := make([]*model.Station, len(stations))
	for i, s := range stations {
		result[i] = &model.Station{
			ID:             s.ID,
			Name:           s.Name,
			State:          s.State,
			Region:         s.Region,
			Distance:       s.Distance,
			Latitude:       s.Latitude,
			Longitude:      s.Longitude,
			Source:         string(s.Source),
			Capabilities:   s.Capabilities,
			TimeZoneOffset: s.TimeZoneOffset,
		}
	}

	return result, nil
}

// Tides is the resolver for the tides field.
func (r *queryResolver) Tides(ctx context.Context, stationID string, startDateTime string, endDateTime string) (*model.TideData, error) {
	if r.TideService == nil {
		return nil, fmt.Errorf("TideService is not initialized")
	}

	response, err := r.TideService.GetCurrentTideForStation(ctx, stationID, &startDateTime, &endDateTime)
	if err != nil {
		return nil, err
	}

	if response == nil {
		return nil, fmt.Errorf("response is nil")
	}

	predictions := make([]*model.TidePrediction, len(response.Predictions))
	for i, p := range response.Predictions {
		predictions[i] = &model.TidePrediction{
			Timestamp: int(p.Timestamp),
			LocalTime: p.LocalTime,
			Height:    p.Height,
		}
	}

	extremes := make([]*model.TideExtreme, len(response.Extremes))
	for i, e := range response.Extremes {
		extremes[i] = &model.TideExtreme{
			Type:      string(e.Type),
			Timestamp: int(e.Timestamp),
			LocalTime: e.LocalTime,
			Height:    e.Height,
		}
	}

	var tideType string
	if response.TideType != nil {
		tideType = string(*response.TideType)
	}

	var waterLevel, predictedLevel float64
	if response.WaterLevel != nil {
		waterLevel = *response.WaterLevel
	}
	if response.PredictedLevel != nil {
		predictedLevel = *response.PredictedLevel
	}

	tzOffset := 0
	if response.TimeZoneOffsetSeconds != nil {
		tzOffset = *response.TimeZoneOffsetSeconds
	}

	return &model.TideData{
		Timestamp:             int(response.Timestamp),
		LocalTime:             response.LocalTime,
		WaterLevel:            waterLevel,
		PredictedLevel:        predictedLevel,
		NearestStation:        response.NearestStation,
		Location:              response.Location,
		Latitude:              response.Latitude,
		Longitude:             response.Longitude,
		StationDistance:       response.StationDistance,
		TideType:              tideType,
		CalculationMethod:     response.CalculationMethod,
		Predictions:           predictions,
		Extremes:              extremes,
		TimeZoneOffsetSeconds: tzOffset,
	}, nil
}

// Query returns generated1.QueryResolver implementation.
func (r *Resolver) Query() generated1.QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
